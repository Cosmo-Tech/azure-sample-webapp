# Scenario parameters

## Overview

In the _Scenario_ view, the top half of the screen represents the parameters that users can modify before running a
scenario (a.k.a. "**scenario parameters**"). The content of the scenario parameters panel is automatically generated
based on the Solution description you defined with the Cosmo Tech API:

- an **input field** is added for each scenario parameter, the graphical component depending on the parameter type
- **tabs** are created to organize parameters into logical groups

Through simple configuration, you will be able to define the list of scenario parameters, organize them into groups,
or even hide parameters or group of parameters.

## Scenario parameters definition

By default, scenario parameters tabs will be generated by the webapp based on the data provided in your solution
description (e.g. the file _Solution.yaml_ that you used to create your Cosmo Tech solution).

Your solution description must contain at least these three sets of information for the tabs to be generated:

- `parameters`: a list of **scenario parameters** objects
- `parameterGroups`: a list of **parameters groups** objects
- `runTemplates`: a list of **run template** objects

_Note: To get the full documentation of the solution description data, read the
[Cosmo Tech API documentation](https://github.com/Cosmo-Tech/cosmotech-api/blob/main/doc/Models/Solution.md). Please
note though that some fields documented in the Solution description may not be used yet in the web-app (e.g. the
`regexValidation` field of parameters)._

Because each scenario is associated to a run template when it is created, the webapp can determine the groups of
parameters to display for each one. A tab is generated for each parameter group, and this tab contains one input
component for each parameter of this group. **The type of input component rendered and its behavior depends on the
varType of the parameter**.

### Parameters

Parameters can be defined with the following properties:

| key            | mandatory/optional | description                                                                                                                                                                                  |
| -------------- | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`           | mandatory          | unique id of the parameter                                                                                                                                                                   |
| `varType`      | mandatory          | variable type of the scenario parameter. Supported types are **enum**, **list**, **string**, **int**, **number**, **bool**, **date**, **%DATASETID%**                                        |
| `defaultValue` | optional           | default value for this parameter when a new scenario is created                                                                                                                              |
| `minValue`     | optional           | Minimum value (when applicable)                                                                                                                                                              |
| `maxValue`     | optional           | Maximum value (when applicable)                                                                                                                                                              |
| `labels`       | optional           | a dict of labels for this parameter, the keys of the dict being the code ISO 639-1 of the language, and the values being the corresponding label                                             |
| `options`      | optional           | a dict of additional properties to customize the behavior and rendering of the scenario parameter in the webapp. Available options will be detailed in the next sections of the current page |

### Parameters groups

Parameters groups can define the following properties:

| key                                          | mandatory/optional | description                                                                                                                                                                                                                                                      |
| -------------------------------------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`                                         | mandatory          | unique id of the parameter group                                                                                                                                                                                                                                 |
| `parameters`                                 | mandatory          | fields to list the ids of the parameters that are part of this group                                                                                                                                                                                             |
| `labels`                                     | optional           | a dict of labels for this parameter group, the keys of the dict being the code ISO 639-1 of the language,                                                                                                                                                        |
| and the values being the corresponding label |
| `authorizedRoles`                            | optional           | an array of "_[Business roles](https://github.com/Cosmo-Tech/cosmotech-api-common/blob/main/src/main/kotlin/com/cosmotech/api/security/AbstractSecurityConfiguration.kt#L17-L23)_" allowed to see the scenario parameters tab (by default, all tabs are visible) |
| `hideParameterGroupIfNoPermission`           | optional           | boolean value defining whether or not a tab should be displayed if the connected user roles do not match the `authorizedRoles` list (visible by default)                                                                                                         |
| `options`                                    | optional           | a dict of additional properties to customize the behavior and rendering of the scenario parameters group in the webapp. Available options will be detailed in the next sections of the current page                                                              |

### Run templates

| key               | mandatory/optional | description                                                                          |
| ----------------- | ------------------ | ------------------------------------------------------------------------------------ |
| `id`              | mandatory          | unique id of the run template                                                        |
| `parameterGroups` | mandatory          | an array containing the ids of the parameters groups to display in this run template |

## Configuration

In addition to the fields documented in the Cosmo Tech API documentation page for
[run template parameters](https://github.com/Cosmo-Tech/cosmotech-api/blob/main/doc/Models/RunTemplateParameter.md),
additional keys can be added in the `options` field to customize the behavior of scenario parameters in the webapp.

You can find many examples of parameters configuration in the
[Solution description](https://github.com/Cosmo-Tech/brewery_sample_solution/blob/main/Solution.yaml#L9) of our brewery
model.

### Parameters of type enum

When using a scenario parameter of type enum, you have to declare in your solution description the list of possible
values the enum can take (values sent to and received from the Cosmo Tech API), and the labels that will be displayed in
the front-end interface for each value.

This can be done in `options.enumValues`, as a list of objects with two properties:

- `key`: the string-based representation of your enum value, that will be sent to the parameters handler
- `value`: the label that will be displayed for this key in the selection list of the enum input component

The labels of enum values can be translated, by providing a dictionary of translations, with language codes as keys.

Example:

```yaml
parameters:
  - id: 'currency'
    labels:
      fr: 'Symbole de la monnaie'
      en: 'Currency symbol'
    varType: 'enum'
    defaultValue: 'USD'
    options:
      enumValues:
        - key: 'USD'
          value:
            en: 'United States dollar ($)'
            fr: 'Dollar américain ($)'
        - key: 'EUR'
          value: 'Euro (€)'
        - key: 'BTC'
          value: 'Bitcoin (฿)'
        - key: 'JPY'
          value:
            en: 'Japanese yen (¥)'
            fr: 'Yen (¥)'
```

### Parameters of type list

List parameters are used to store the string representation of a list of values. Their configuration is similar to enum
parameters: you have to declare the list of possible keys (the string items that will be sent to the back-end), and
the label that will be displayed in the webapp, in a multi-selection component, for each key.

When the scenario is saved, the selected values will be serialized into a string representing a JSON list, such as
`["USD","EUR","JPY"]`, and saved in the scenario `parameterValues`.

The configuration of the possible list values is identical to the configuration of values of enum parameters, it is done
in `options.enumValues`, as a list of objects with two properties:

- `key`: the string-based representation of your list item, that will be sent to the parameters handler
- `value`: the label that will be displayed for this key in the selection list of the multi-selection component

The labels of enum values can be translated, by providing a dictionary of translations, with language codes as keys.

The main difference in the configuration between enum and list parameters is the **definition of the default value**:
For `list` parameters, it must be the **string representation of an array**, even if there is only one value
(examples: `[]`, `["USD"]`, `["USD","EUR"]`).

Example:

```yaml
parameters:
  - id: 'currency'
    labels:
      fr: 'Symbole de la monnaie'
      en: 'Currency symbol'
    varType: 'list'
    defaultValue: '["USD","EUR"]'
    options:
      enumValues:
        - key: 'USD'
          value:
            en: 'United States dollar ($)'
            fr: 'Dollar américain ($)'
        - key: 'EUR'
          value: 'Euro (€)'
        - key: 'BTC'
          value: 'Bitcoin (฿)'
        - key: 'JPY'
          value:
            en: 'Japanese yen (¥)'
            fr: 'Yen (¥)'
```

### Dynamic values for enum and list parameters

In some cases, for **enum** and **list** parameters, you may want to automatically retrieve the list of possible values
from a dataset, in order to only show the relevant values in the dropdown list. This feature is called
**dynamic values**, and is supported for scenario parameters and for the parameters of subdataset creation ETLs.

To configure dynamic values, you have to define `options.dynamicEnumValues`, an object with the following keys:

- `type` (optional): the type of request that will retrieve the dynamic values; currently the only supported value is
  `cypher`, to use cypher queries on a twingraph dataset, but more options will be added in the future
  (default: `cypher`)
- `query`: the cypher query to run on a twingraph dataset; this query must retrieve a list of property values of the
  graph elements, and return them with an alias (example: `MATCH(n:Customer) RETURN n.id as id`)
- `resultKey`: the alias defined in your query; providing this value is required for the webapp to parse the cypher
  query results, and retrieve the actual values to display in the enum

Please note that the **target dataset** on which the cypher query will be run **depends on the context**:

- in the dataset manager view, dynamic values can only be used when **creating sub-datasets**, and the target dataset
  is the parent dataset
- in the scenario view, the target dataset is the first dataset associated to the scenario (in scenario property
  `datasetList`)

The `enumValues` option for "static" values can still be used to have a fallback in case the query fails, but
defining both static and dynamic values options is not advised, because values from both sources may not always be
consistent, and could lead to unexpected behavior in the webapp.

Configuration example:

```yaml
parameters:
  - id: etl_param_subdataset_filter_dynamic_customer_name
    labels:
      fr: Filtrer par client
      en: Filter by customer
    varType: enum
    options:
      dynamicEnumValues:
        type: cypher
        query: 'MATCH(n:Customer) RETURN n.id as id'
        resultKey: id
```

### File parameters

When using a scenario parameter with the _varType_ `%DATASETID%` (e.g. dataset parts), you have to declare some
information about it in the `options` field of the parameter description:

- `defaultFileTypeFilter`: a comma-separated list of files extensions that will be used as the default filter in users'
  file browser
- `connectorId`: the connector id to use in the dataset object that will be created with the Cosmo Tech API
- `description`: the description to use in the dataset object that will be created with the Cosmo Tech API

> **Warning**
>
> Currently, the file scenario parameters (for "file upload" and "table" components) only work with Azure
> Storage connectors. The connector whose id you provide **must have the exact name "Azure Storage Connector"**.

When files uploaded by webapp users are sent to the back-end to be stored (for example in Azure Storage), the original
file name is preserved. This behavior can be inconvenient when writing the parameters handler of your solution. If you
want to have more predictable names for the files uploaded with the webapp, you can enable the option
`options.shouldRenameFileOnUpload` to force the renaming of files uploaded by users before they are sent to the
back-end. When this option is enabled, a new file name is generated by concatenating the parameter id with the extension
of the uploaded file (e.g._initial_stock_dataset.csv_)

Finally, if you want to have a default file present when creating a new scenario, you can provide the id of an existing
dataset in the `defaultValue` property.

Example:

```yaml
parameters:
  - id: 'initial_stock_dataset'
    labels:
      fr: 'Stock de départ'
      en: 'Initial stock'
    varType: '%DATASETID%'
    defaultValue: 'd-kpq7nw4m5rwng'
    options:
      connectorId: 'c-d7e5p9o0kjn9'
      description: 'Initial stock dataset part'
      defaultFileTypeFilter: '.zip,.csv,.json,.xls,.xlsx'
      shouldRenameFileOnUpload: true
```

### Table parameters

#### Description

The sample webapp provides a generic component to let users edit a data table, with CSV and Excel import/export
features.

These "Table" scenario parameters use the same `%DATASETID%` _varType_ as the "File" parameters, but the table edition
mode is enabled by setting `options.subType` to `TABLE`. The `options` dict can contain the following options:

- `connectorId`: the connector id to use in the dataset object that will be created with the Cosmo Tech API
- `description`: the description to use in the dataset object that will be created with the Cosmo Tech API
- `subType`: set its value to `TABLE` to make use of the _extended var type_ feature
- `columns`: an array describing **the expected columns of the table** (see section below "Columns definition")
- `canChangeRowsNumber`: a boolean defining if the table can use the add row and delete rows features (default: `false`); this option is forced to `false` if some columns are non-editable
- `dateFormat`: a string describing the expected format of dates in the table based on
  [date-fns format patterns](https://date-fns.org/v2.25.0/docs/parse) (default: `yyyy-MM-dd`)

Example:

```yaml
parameters:
  - id: 'customers'
    labels:
      fr: 'Clients'
      en: 'Customers'
    varType: '%DATASETID%'
    options:
      subType: 'TABLE'
      connectorId: 'c-d7e5p9o0kjn9'
      description: 'customers data'
      columns:
        - field: 'name'
          type:
            - 'nonEditable'
        - field: 'age'
          type:
            - 'int'
          minValue: 0
          maxValue: 120
          defaultValue: 60
        - field: 'birthday'
          type:
            - 'date'
          minValue: '1900-01-01'
          maxValue: '2022-12-19T13:46:15.223Z'
          acceptsEmptyFields: true
      canChangeRowsNumber: false
      dateFormat: 'dd/MM/yyyy'
```
#### Data source
By default, the table component is empty but if you want to display some data, you can define either a default or dynamic
value for the parameter. You can provide the id of an existing dataset in the `defaultValue` property of the parameter
description (this dataset must be a CSV file, with values separated by commas). If you want to fetch data from scenario's
dataset, you can use `dynamicValues` option that uses a cypher query to retrieve data from twingraph dataset.

_Note: only a **cypher** query from **twingraph** dataset is supported_


`dynamicValues` is an object with the following keys:

- `query`: the cypher query to run on a twingraph dataset; this query must retrieve a list of property values of the
  graph elements, and return them with an alias (example: `MATCH(n:Customer) WITH {name: n.name, age: n.age} as alias 
RETURN alias`). Names of the properties must correspond to the `field` key in columns definition.
- `resultKey`: the alias defined in your query; providing this value is required for the webapp to parse the cypher
  query results, and retrieve the actual values to display in the table

Example of typical queries:

_Retrieve nodes from dataset, e.g., all nodes Customer with its properties_
```yaml
'MATCH(customer: Customer) WITH {name: customer.id, satisfaction: customer.Satisfaction} as fields RETURN fields'
```
_Retrieve edges from dataset, e.g. relationship between all bars and customers_
```yaml
'MATCH (b:Bar)-[r]->(c:Customer) WITH {bar: b.id, customer: c.id, relation: r.name } as fields RETURN fields'
```

Complete example:
```yaml
parameters:
  - id: 'customers'
    labels:
      fr: 'Clients'
      en: 'Customers'
    varType: '%DATASETID%'
    options:
      subType: 'TABLE'
      connectorId: 'c-d7e5p9o0kjn9'
      description: 'customers data'
      dynamicValues:
        query: 'MATCH(customer: Customer) WITH {name: customer.id, satisfaction: customer.Satisfaction} as fields RETURN fields'
        resultKey: 'fields'
      columns:
        - field: 'name'
          type:
            - 'nonEditable'
        - field: 'satisfaction'
          type:
            - 'int'
          minValue: 0
          maxValue: 120
      canChangeRowsNumber: false
```

_Known issue: Dynamic parameters are not saved as scenario parameters if they weren't displayed. 
In order to save it, users need to open the parameter's tab that will trigger the query_

#### Columns definition

The description of the table columns consists of an array of objects with the following attributes:

- **field** (_mandatory_) name of the column
- **type** (_optional_) list of options defining the **value type** and **behavior** of the column (only one value type
  is allowed); authorized options are:
  - **string** (_value type_), this is the default value type if none is provided
  - **int** (_value type_)
  - **number** (_value type_)
  - **enum** (_value type_)
  - **bool** (_value type_)
  - **date** (_value type_)
  - **nonResizable** (_behavior_)
  - **nonEditable** (_behavior_)
  - **nonSortable** (_behavior_)
- **minValue** (_optional_) minimum value accepted on edition (for column types _int_, _number_ and _date_)\*
- **maxValue** (_optional_) maximum value accepted on edition (for column types _int_, _number_ and _date_)\*
- **defaultValue** (_optional_) default value to use when users add new lines; if no default value is defined, the webapp will choose a default value **based on the column type**.
- **enumValues** (_optional_) list of known enum values, accepted on edition (for column type _enum_)
- **acceptsEmptyFields** (_optional_) set to `true`, authorizes the column to accept empty fields (default `false`)

For columns of type `date`, when providing values for the options `minValue`, `maxValue` and `defaultValue`,
the **ISO format** is recommended (these values will be forwarded to the standard JS `Date` constructor).

Example:

```yaml
parameters:
  - id: 'customers'
    labels:
      fr: 'Clients'
      en: 'Customers'
    varType: '%DATASETID%'
    options:
      connectorId: 'c-d7e5p9o0kjn9'
      description: 'customers data'
      subType: 'TABLE'
      columns:
        - field: 'name'
          type:
            - 'nonResizable'
            - 'nonEditable'
            - 'nonSortable'
        - field: 'age'
          type:
            - 'int'
          minValue: 0
          defaultValue: 60
          maxValue: 120
          acceptsEmptyFields: true
        - field: 'canDrinkAlcohol'
          type:
            - 'bool'
        - field: 'favoriteDrink'
          type:
            - 'enum'
          defaultValue: 'OrangeJuice'
          enumValues:
            - 'AppleJuice'
            - 'Beer'
            - 'OrangeJuice'
            - 'Wine'
        - field: 'birthday'
          type:
            - 'date'
          minValue: '1900-01-01'
          maxValue: '2022-12-19T13:46:15.223Z'
          acceptsEmptyFields: true
        - field: 'height'
          type:
            - 'number'
          minValue: 0
          maxValue: 2.5
          acceptsEmptyFields: true
```

Notes:

- defining several times the same field will result in undefined behavior
- setting different value types in the `type` attribute will result in undefined behavior

#### Column grouping definition

The description of the table groups consists of putting columns in the same group. Each group needs to have the following fields:

- **headerName**: name of the column group
- **children**: array of columns or column groups belonging to this group

Columns inside a group can be conditionally shown or hidden based on the "open" or "closed" state of the group. This
can be defined by setting the option `columnGroupShow` in the column definition to either `open` or `closed`:

- when set to `open`, the child is only shown when the group is open
- when set to `closed`, the child is only shown when the group is closed

Example:

```yaml
parameters:
  - id: 'customers'
    labels:
      fr: 'Clients'
      en: 'Customers'
    varType: '%DATASETID%'
    options:
      connectorId: 'c-d7e5p9o0kjn9'
      description: 'customers data'
      subType: 'TABLE'
      columns:
        - headerName: 'First group'
          children:
            - field: 'name'
              type:
                - 'nonResizable'
                - 'nonEditable'
                - 'nonSortable'
              columnGroupShow: 'open'
            - field: 'age'
              type:
                - 'int'
              minValue: 0
              maxValue: 120
              acceptsEmptyFields: true
              columnGroupShow: 'closed'
        - field: 'canDrinkAlcohol'
          type:
            - 'bool'
        - field: 'favoriteDrink'
          type:
            - 'enum'
          enumValues:
            - 'AppleJuice'
            - 'Beer'
            - 'OrangeJuice'
            - 'Wine'
        - headerName: 'Second Group'
          children:
            - field: 'birthday'
              type:
                - 'date'
              minValue: '1900-01-01'
              maxValue: '2022-12-19T13:46:15.223Z'
              acceptsEmptyFields: true
            - field: 'height'
              type:
                - 'number'
              minValue: 0
              maxValue: 2.5
              acceptsEmptyFields: true
```

### Hidden scenario parameters & hidden parameters groups

For some specific use cases, you may want to have **hidden** parameters or group of parameters:

- these parameters are not visible and cannot be edited in the webapp
- their values are sent to the Cosmo Tech API when saving changes

Because their values cannot be edited by users, you must either set a default value in your solution for these
parameters, or customize the webapp to set a dynamic value.

The sample webapp already implements a specific behavior with dynamic values to easily add some "metadata" to the
scenario parameters, such as the scenario id, its name or other data. More details can be found in the section
"_Additional scenario run parameters_".

In your solution description, the option to define whether a parameter is hidden is
`parameters.[parameter].options.hidden`.

Example:

```yaml
parameters:
  - id: 'myHiddenParameter'
    options:
      hidden: true
    varType: int
    defaultValue: 100
```

Similarly, groups of parameters can be described as `hidden` to hide the associated group tab in the _Scenario_ view.
Users won't be able to see or edit the parameters of this group, but the parameters values will be included in the
scenario data when the scenario is saved.

In your solution description, the option to hide a group of parameters is
`parameterGroups.[parameterGroup].options.hidden`.

Example:

```yaml
parameterGroups:
  - id: 'myHiddenGroup'
    options:
      hidden: true
    parameters: ['parameter1', 'parameter2']
```

### Information tooltips for scenario parameters

In order to help users of your solution, you can provide a short description of the scenario parameters that will be
displayed in a tooltip when hovering an icon next to the parameter name label. To enable this feature, you simply have
to define `options.tooltipText`, as a dict of labels for the languages available in your application.

Example:

```yaml
parameters:
  - id: 'currency'
    labels:
      fr: 'Symbole de la monnaie'
      en: 'Currency symbol'
    varType: 'enum'
    defaultValue: 'USD'
    options:
      enumValues:
        - key: 'USD'
          value:
            en: 'United States dollar ($)'
            fr: 'Dollar américain ($)'
        - key: 'EUR'
          value: 'Euro (€)'
        - key: 'BTC'
          value: 'Bitcoin (฿)'
        - key: 'JPY'
          value:
            en: 'Japanese yen (¥)'
            fr: 'Yen (¥)'
      tooltipText:
        fr: "Choisissez un symbole :\n\t- $\n\t- €\n\t- ฿\n\t- ¥"
        en: "Choose a symbol:\n\t- $\n\t- €\n\t- ฿\n\t- ¥"
```

### Validation

To prevent errors of user's input in front-end interface, generic components for parameters of type date, number, int, string and bool are implemented with some validation rules such as `required`, `isInteger`,
`minValue` and `maxValue`, `minDate` and `maxDate`, `minLength` and `maxLength`.

Alongside basic validation, it is possible to configure some constraining rules between parameters
which can be useful for parameters like _Start date_ and _End date_. Following constraints can be defined:

| constraint               | symbol | acceptable varTypes             |
| ------------------------ | ------ | ------------------------------- |
| greater than             | `>`    | date, number, int               |
| less then                | `<`    | date, number, int               |
| greater than or equal to | `>=`   | date, number, int               |
| less than or equal to    | `<=`   | date, number, int               |
| equal to                 | `==`   | date, number, int, string, bool |
| different from           | `!=`   | date, number, int, string, bool |

_Note: For this type of validation to work, both parameters must belong to the same parameter group_

Constraints must be defined in options as a plain string and contain the type of the constraint and the id of constraining parameter:

```yaml
parameters:
  - id: 'end_date'
    options:
      validation: '> start_date'
```

Declaring mutual constraints on two parameters like that:

```yaml
parameters:
  - id: 'start_date'
    options:
      validation: '< end_date'
  - id: 'end_date'
    options:
      validation: '> start_date'
```

can lead to a user-unfriendly behaviour, it is recommended to declare the constraint on one parameter.

Below are listed all validation rules for each varType.

#### Date

| validation rule | default/optional | description                                                |
| --------------- | ---------------- | ---------------------------------------------------------- |
| required        | default          |                                                            |
| minDate         | optional         | can be declared as `minValue` key in parameter description |
| maxDate         | optional         | can be declared as `maxValue` key in parameter description |
| constraint      | optional         | can be defined between two parameters with `date` varType  |

Example:

```yaml
parameters:
  - id: 'end_date'
    varType: date,
    minValue: '2021-01-01T00:00:00.000Z',
    maxValue: '2022-12-31T00:00:00.000Z',
    options:
      validation: '> start_date'
```

#### Number and Int

| validation rule | default/optional | description                                                               |
| --------------- | ---------------- | ------------------------------------------------------------------------- |
| required        | default          |                                                                           |
| integer         | default          | parameters with varType `int` will be automatically validated as integers |
| minValue        | optional         | can be declared as `minValue` key in parameter description                |
| maxValue        | optional         | can be declared as `maxValue` key in parameter description                |
| constraint      | optional         | can be defined between two parameters with `int` or `number` varType      |

Example:

```yaml
parameters:
  - id: 'restock'
    varType: int,
    minValue: 1,
    maxValue: 1000,
    options:
      validation: '< stock'
```

#### String

| validation rule | default/optional | description                                                                                                                                 |
| --------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| required        | optional         | all strings are optional by default, to make a string parameter required, `minLength` option in `options.validation` must be greater than 0 |
| minLength       | optional         | can be declared as `minLength` in parameter's `options`                                                                                     |
| maxLength       | optional         | can be declared as `maxLength` in parameter's `options`                                                                                     |
| constraint      | optional         | can be defined between two parameters with `string` varType                                                                                 |

Example:

```yaml
parameters:
  - id: 'comment'
    options:
      minLength: 1,
      maxLength: 100,
      validation: '!= evaluation'
```

#### Bool

| validation rule | default/optional | description                                               |
| --------------- | ---------------- | --------------------------------------------------------- |
| constraint      | optional         | can be defined between two parameters with `bool` varType |

Example:

```yaml
parameters:
  - id: 'activated'
    options:
      validation: '!= inMaintenance'
```

## Overriding the solution configuration

Updating the solution configuration via the Cosmo Tech API (with restish or swagger) can be a slow, cumbersome and
error-prone process. A simpler way to iterate on the scenario parameters configuration during development is to use the
file [src/config/overrides/Solutions.js](../src/config/overrides/Solutions.js). This file can be used to override the
configuration of any solution, by patching the solution data sent by the Cosmo Tech API.

Open the file and modify the `SOLUTIONS` constant, that contains an array of solution objects. These objects must
contain an `id` property, that will be used to patch the matching solution sent by the API.

Here is an example of how to override the parameters, groups, and run templates configuration via the
[src/config/overrides/Solutions.js](../src/config/overrides/Solutions.js) file:

```js
export const SOLUTIONS = [
  {
    id: 'SOL-VkqXyNONQyB', // id of the solution to override
    // override parameters definition
    parameters: [
      {
        id: 'nb_waiters',
        defaultValue: 10,
      },
      {
        id: 'restock_qty',
        defaultValue: 250,
      },
      {
        id: 'stock',
        defaultValue: 1000,
      },
    ],
    // override parameters groups
    parameterGroups: [
      {
        id: 'org',
        labels: {
          en: 'Pub parameters',
          fr: 'Paramètres du bar',
        },
        parameters: ['stock', 'restock_qty', 'nb_waiters'],
      },
      {
        id: 'finance',
        parameters: ['currency', 'currency_name', 'currency_value', 'currency_used'],
      },
    ],
    // override run templates
    runTemplates: [
      {
        id: 'myRunTemplate_1',
        parameterGroups: ['bar_parameters', 'file_upload'],
      },
      {
        id: 'myRunTemplate_2',
        parameterGroups: ['basic_types', 'dataset_parts', 'extra_dataset_part'],
      },
    ],
  },
];
```

_Important: You can use this file to reorganize the scenario parameters tabs by changing the parameters belonging to
parameters groups but **the set of parameters associated to a run template must remain consistent with the solution
configuration file** (Solution.yaml)._

## Additional scenario run parameters

In addition to the scenario parameters that are editable by the webapp users, it can be useful to add some
**scenario metadata** (e.g. the scenario id, the run template name, ...) to the information sent to Cosmo Tech API
before running the scenario. These data could then be available for pre-processing scripts and results analysis. Yet,
it wouldn't be a good idea to ask users to edit such scenario parameters, it would be better to **hide them**,
**generate them dynamically** based on the current scenario, and **send them** along the actually editable scenario
parameters.

The webapp automates all these actions, by relying entirely on
**the ids of the scenario parameters of the current run template**. This means that you only needs to declare a hidden
scenario parameter with a specific id for the webapp to automatically fill its value and send it when updating the
scenario parameters. Here is the list of reserved parameters ids you can use:

| parameter id        | description                                           |
| ------------------- | ----------------------------------------------------- |
| `ScenarioName`      | the name of the current scenario                      |
| `ScenarioId`        | the id of the current scenario                        |
| `ParentId`          | the id of the parent of the current scenario          |
| `MasterId`          | the id of the root scenario of the current scenario   |
| `RunTemplateName`   | the name of the run template of the current scenario  |
| `ScenarioLastRunId` | the last run id of the current scenario               |
| `ParentLastRunId`   | the last run id of the parent of the current scenario |
| `MasterLastRunId`   | the last run id of the master of the current scenario |

## Input components metadata for Cypress tests

If you want to test the scenario parameters input components in an automated test framework, you will probably need
to find the metadata tags on the generated components. A `data-cy` property is added to the scenario parameters input
components, whose value depend on the **input component type** and the **parameter id**, with the following pattern:
`<input component type>-<parameter id>` (e.g. `number-input-stock`).

Here is the list of `data-cy` patterns for all generic input components provided by the azure-sample-webapp:

| varType       | subType     | input component      | `data-cy` pattern               |
| ------------- | ----------- | -------------------- | ------------------------------- |
| `bool`        |             | Switch boolean input | `toggle-input-<parameterId>`    |
| `date`        |             | Date picker          | `date-input-<parameterId>`      |
| `enum`        |             | Dropdown list        | `enum-input-<parameterId>`      |
| `enum`        | `RADIO`     | Radio buttons        | `radio-input-<parameterId>`     |
| `enum`        | `SCENARIOS` | Scenarios select     | `scenarios-input-<parameterId>` |
| `int`         |             | Number input         | `number-input-<parameterId>`    |
| `number`      |             | Number input         | `number-input-<parameterId>`    |
| `number`      | `SLIDER`    | Slider               | `slider-input-<parameterId>`    |
| `string`      |             | Text field           | `text-input-<parameterId>`      |
| `%DATASETID%` |             | File upload          | `file-upload-<parameterId>`     |
| `%DATASETID%` | `TABLE`     | Editable table       | `table-<parameterId>`           |
